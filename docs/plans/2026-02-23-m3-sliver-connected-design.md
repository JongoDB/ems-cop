# M3 Design — Sliver Connected

Connect the C2 Gateway to Sliver's gRPC API so operators can list sessions, execute commands, and open interactive shells from the browser. Log every C2 action to the audit trail.

---

## Decisions Made

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Sliver protobuf import | Direct `go get github.com/bishopfox/sliver/protobuf` | Type-safe, stays in sync with Sliver releases |
| Interactive shell routing | Direct WebSocket on c2-gateway | Low latency; NATS hop would add lag to every keystroke |
| M3 scope | 6 of 12 provider methods | Ship the demo loop; defer implant generation, listener CRUD, telemetry |
| Frontend location | New `/c2` page | Clean separation from tickets; natural home for future C2 features |
| Audit logging | c2-gateway publishes to NATS | Consistent with auth/ticket services; audit-service already subscribes to `c2.>` |

---

## 1. Sliver Provider — gRPC Connection

### New dependencies (`services/c2-gateway/go.mod`)

```
github.com/bishopfox/sliver/protobuf
google.golang.org/grpc
github.com/gorilla/websocket
github.com/nats-io/nats.go
```

### Connection flow

1. On startup, read the operator config file at `SLIVER_OPERATOR_CONFIG` (`/home/sliver/.sliver/configs/ems-operator.cfg`). This file is generated by the Sliver entrypoint and shared via the `sliver-config` Docker volume (read-only mount on c2-gateway).
2. Parse the operator config JSON to extract: CA certificate, client certificate, client private key, and server lhost/lport.
3. Build a `tls.Config` with the mTLS credentials.
4. Dial `sliver-server:31337` with `grpc.WithTransportCredentials(credentials.NewTLS(tlsConfig))`.
5. Create a `rpcpb.SliverRPCClient` from the connection.
6. If the connection fails on startup, log a warning and retry every 10 seconds in a background goroutine. The health endpoint reports `"sliver": "disconnected"` until the connection succeeds.

### SliverProvider struct

```go
type SliverProvider struct {
    config     ProviderConfig
    conn       *grpc.ClientConn
    rpc        rpcpb.SliverRPCClient
    mu         sync.RWMutex
    connected  bool
}
```

---

## 2. Provider Method Implementations

### ListSessions

Call `rpc.GetSessions(ctx, &commonpb.Empty{})`. Map each `clientpb.Session` to the EMS `Session` struct:

| Sliver field | EMS field |
|---|---|
| `ID` | `ID` |
| `Name` | `ImplantID` |
| `Hostname` | `Hostname` |
| `OS` | `OS` |
| `RemoteAddress` | `RemoteAddr` |
| `Transport` | `Transport` |
| `IsDead` | `IsAlive` (inverted) |
| `LastCheckin` | `LastMessage` |

### ListImplants

Call `rpc.ImplantBuilds(ctx, &commonpb.Empty{})`. Map each build to the EMS `Implant` struct. Also call `rpc.GetBeacons(ctx, &commonpb.Empty{})` and merge — beacons are Sliver's async implant type.

### ListListeners

Call `rpc.GetJobs(ctx, &commonpb.Empty{})`. Each Sliver job represents a running listener. Map to EMS `Listener`:

| Sliver field | EMS field |
|---|---|
| `ID` | `ID` (convert int32 to string) |
| `Protocol` | `Protocol` |
| `Port` | `Port` |
| `Name` | `Host` |

### ExecuteTask

Route `task.Command` to the matching Sliver RPC:

| Command | Sliver RPC | Request type |
|---------|-----------|-------------|
| `ls` | `Ls` | `sliverpb.LsReq{Path, Request}` |
| `ps` | `Ps` | `sliverpb.PsReq{Request}` |
| `pwd` | `Pwd` | `sliverpb.PwdReq{Request}` |
| `whoami` | `GetEnv` | `sliverpb.EnvReq{Name: "USER", Request}` |
| `ifconfig` | `Ifconfig` | `sliverpb.IfconfigReq{Request}` |
| `netstat` | `Netstat` | `sliverpb.NetstatReq{Request}` |
| `cat` | `Download` | `sliverpb.DownloadReq{Path, Request}` |
| `upload` | `Upload` | `sliverpb.UploadReq{Path, Data, Request}` |
| `download` | `Download` | `sliverpb.DownloadReq{Path, Request}` |
| `screenshot` | `Screenshot` | `sliverpb.ScreenshotReq{Request}` |
| `execute` | `Execute` | `sliverpb.ExecuteReq{Path, Args, Output, Request}` |

Every `Request` field embeds `commonpb.Request{SessionID, Timeout}`.

The handler serializes Sliver's protobuf response to a human-readable string for `TaskResult.Output`. For `ls`, format as a file listing. For `ps`, format as a process table. For `screenshot`, base64-encode and return a data URI.

### OpenSession (interactive shell)

Call `rpc.Shell(ctx, &sliverpb.ShellReq{Path: "/bin/sh", EnablePTY: true, Request: ...})`. This returns a `sliverpb.Shell` with a `TunnelID`. Then use `rpc.TunnelData` bidirectional stream to send stdin and receive stdout/stderr.

The `SessionStream` interface wraps this:
- `Send(input)` → write to tunnel stream
- `Recv()` → read from tunnel stream
- `Close()` → close tunnel, kill shell process

---

## 3. WebSocket Shell Handler

### Upgrade flow

1. `GET /api/v1/c2/sessions/{sessionID}/shell` arrives at c2-gateway.
2. Traefik ForwardAuth validates the JWT (user must be authenticated).
3. Handler upgrades HTTP to WebSocket using `gorilla/websocket.Upgrader`.
4. Handler calls `provider.OpenSession(ctx, sessionID)` to get a `SessionStream`.
5. Two goroutines:
   - **Read loop**: read from WebSocket → `stream.Send(input)` → Sliver
   - **Write loop**: `stream.Recv()` from Sliver → write to WebSocket
6. On WebSocket close or error, call `stream.Close()` and publish `c2.session_closed` to NATS.
7. On connect, publish `c2.session_opened` to NATS.

### Traefik WebSocket support

Traefik supports WebSocket upgrades natively. The existing `c2` router at `/api/v1/c2` already points to c2-gateway. No config changes needed — Traefik detects the `Upgrade: websocket` header and proxies the connection.

---

## 4. NATS Audit Events

Add NATS connection to `C2GatewayServer`. Publish JSON events on these subjects:

| Subject | When | Payload |
|---------|------|---------|
| `c2.command_executed` | After `ExecuteTask` returns | `{event_type, actor_id, actor_username, session_id, resource_type: "c2_session", resource_id: sessionID, action: task.Command, details: JSON(task.Arguments), timestamp}` |
| `c2.session_opened` | WebSocket shell connects | `{event_type, actor_id, session_id, resource_type: "c2_session", resource_id: sessionID, action: "shell_open", timestamp}` |
| `c2.session_closed` | WebSocket shell disconnects | Same as above with `action: "shell_close"` |

The `actor_id` and `actor_username` come from the `X-User-ID` and `X-User-Roles` headers set by ForwardAuth. The c2-gateway must read these headers from the request.

The audit service already subscribes to `c2.>` and writes to ClickHouse with hash chaining. No changes needed on the audit side.

---

## 5. Frontend — `/c2` Page

### Layout

Split-pane layout:
- **Left sidebar** (300px): Sessions list with status indicators (alive/dead), hostname, OS icon, last checkin time. Click a session to select it.
- **Right panel**: Tabbed view with two tabs:
  - **Terminal** — xterm.js connected to the WebSocket shell
  - **Commands** — Quick-execute buttons for common recon commands (ls, ps, whoami, ifconfig, netstat). Output displayed in a scrollable pre-formatted area.

### Navbar

Same pattern as TicketsPage: EMS-COP brand, TICKETS link, C2 link (active), user badge, logout.

### xterm.js integration

```tsx
// TerminalPanel.tsx
const term = new Terminal({ cursorBlink: true, theme: { background: '#0a0e14' } })
const fitAddon = new FitAddon()
term.loadAddon(fitAddon)
term.open(containerRef.current)
fitAddon.fit()

const ws = new WebSocket(`ws://${location.host}/api/v1/c2/sessions/${sessionId}/shell`)
ws.onmessage = (e) => term.write(e.data)
term.onData((data) => ws.send(data))
```

Use the access token for auth: append `?token=<jwt>` to the WebSocket URL. The c2-gateway WebSocket handler reads the token from the query param (since WebSocket API doesn't support custom headers). Validate the JWT the same way ForwardAuth does.

**Note on ForwardAuth and WebSocket**: Traefik's ForwardAuth runs on the initial HTTP upgrade request, so the `Authorization` header works for the upgrade. However, browsers' `new WebSocket()` API cannot set custom headers. Two options:
- Pass token as query param `?token=jwt` — c2-gateway validates it server-side
- Rely on Traefik ForwardAuth for the upgrade (requires the frontend to set the header via a fetch-based approach)

We use the query param approach — simpler, widely used for WebSocket auth.

### Session list

Fetch `GET /api/v1/c2/sessions` on mount and poll every 10 seconds. Display each session as a row with:
- Status dot (green = alive, red = dead)
- Hostname
- OS (Linux/Windows/macOS icon)
- Remote address
- Last message time (relative, e.g. "2m ago")

### Quick commands panel

A grid of buttons (ls, ps, whoami, ifconfig, netstat, pwd). Clicking one calls `POST /api/v1/c2/sessions/{id}/execute` with `{command: "ls"}`. Response output displayed in a monospace `<pre>` block below the buttons.

---

## 6. App.tsx Route Addition

```tsx
<Route path="/c2" element={<ProtectedRoute><C2Page /></ProtectedRoute>} />
```

Add C2 link to navbar in HomePage and TicketsPage (shared navbar pattern).

---

## 7. Health Endpoint Update

The c2-gateway health endpoint should report Sliver connection status:

```json
{
  "status": "ok",
  "provider": "sliver",
  "sliver_connected": true,
  "active_sessions": 3,
  "time": "2026-02-23T..."
}
```

When Sliver is disconnected: `"status": "degraded"`, `"sliver_connected": false`.

---

## 8. Files to Create/Modify

### Create
- `frontend/src/pages/C2Page.tsx` — session list + terminal + quick commands
- `frontend/src/components/TerminalPanel.tsx` — xterm.js WebSocket wrapper (replaces stub widget)

### Modify
- `services/c2-gateway/main.go` — implement SliverProvider methods, WebSocket handler, NATS publishing, read user headers
- `services/c2-gateway/go.mod` — add sliver/protobuf, grpc, gorilla/websocket, nats.go dependencies
- `frontend/src/App.tsx` — add `/c2` route
- `frontend/src/pages/HomePage.tsx` — add C2 nav link
- `frontend/src/pages/TicketsPage.tsx` — add C2 nav link
- `frontend/src/index.css` — terminal panel and C2 page styles

### No changes needed
- `infra/traefik/dynamic.yml` — existing c2 router already covers `/api/v1/c2/*`, WebSocket upgrades work automatically
- `services/audit/main.go` — already subscribes to `c2.>`
- `docker-compose.yml` — c2-gateway already has correct network config and volume mounts

---

## 9. Verification Plan

1. **gRPC connection**: `docker compose up -d --build c2-gateway` → logs show "connected to sliver" (or retry loop if Sliver is still starting)
2. **List sessions**: `curl -H "Authorization: Bearer $TOKEN" localhost:18080/api/v1/c2/sessions` → returns JSON array (empty if no implants deployed)
3. **List listeners**: Same pattern for `/api/v1/c2/listeners` → returns Sliver's active jobs
4. **Deploy test implant**: Generate implant from Sliver console, deploy to an endpoint container, verify session appears in API
5. **Execute command**: `curl -X POST -H "Authorization: Bearer $TOKEN" -d '{"command":"ls"}' localhost:18080/api/v1/c2/sessions/{id}/execute` → returns file listing from target
6. **Interactive shell**: Open browser to `/c2`, select session, terminal tab → type commands, see output
7. **Audit trail**: `curl -H "Authorization: Bearer $TOKEN" localhost:18080/api/v1/audit/events?event_type=c2.command_executed` → returns logged C2 commands with hash chain
8. **Health check**: `curl localhost:18080/api/v1/c2/health` → shows `sliver_connected: true`
